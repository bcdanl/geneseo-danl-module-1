---
title: Lecture 7
subtitle: Missing Data and Time-series Data [Lecture 7 slides may be subject to change during the Module.]
format:
  clean-revealjs:
    self-contained: true
    #### logo: logo-title-slide.png
author:
  - name: Byeong-Hak Choe
    email: bchoe@geneseo.edu
    affiliations: SUNY Geneseo
date: 2024-03-19
callout-icon: false
execute: 
  eval: false
  echo: true
#### bibliography: refs.bib
#### include-after-body: backwards.html
---


```{r setup}
#| include: false
#| eval: true

library(knitr)
library(tidyverse)
#### set default options
opts_chunk$set(echo = FALSE,
               fig.width = 7.252,
               fig.height = 4,
               comment = "####",
               dpi = 300)

knitr::knit_engines$set("markdown")
```




# Missing Data {background-color="#1c4982"}

## Missing Data 

Rarely will we be given a data set without any missing values.


Pandas usually displays missing values as `NaN`.
  - `NaN` is the actual representation of "Not a Number" values.
  - I would prefer calling it "Not Available" (`NA`), for which some other programming languages as well as Pandas use to represent missing values.
  


## Missing Data 

- The `NaN` value in Pandas comes from Numpy.

```{.python}
from numpy import NaN
NaN == True
NaN == 0
NaN == "
NaN == NaN
```



## Missing Data 


- Pandas has functions to test for missing values, `isnull()`.
- Pandas also has functions for testing non-missing values, `notnull()`.

```{.python}
import pandas as pd
pd.isnull(NaN)
pd.notnull(NaN)
pd.notnull(210)
pd.notnull('missing')
```




##  Where Can Missing Values Come From?
### Load Data

::: {.panel-tabset}
## read_csv()
- When we load the data, Pandas automatically finds the missing data cell and give us a DataFrame with the `NaN` value in the appropriate cell. 

- In the `read_csv()` function, three parameters are related to reading missing values: `na_values` and `keep_default_na`.




## na_values
The `na_values` parameter allows us to specify additional missing or `NaN` values. 


  - We can pass in either a Python `str` (i.e., string) or a list-like object to be automatically coded as missing values when the file is read. 
  

```{.python}
path = 'https://bcdanl.github.io/data/survey_visited.csv'
survey_visited_0 = pd.read_csv(path)
survey_visited_1 = pd.read_csv(path, na_values = ["MSK-4"])
```


## keep_default_na
The `keep_default_na` parameter is a `bool` (i.e., `True` or `False` boolean) that allows us to specify whether any additional values need to be considered as missing. 

- `keep_default_na = False` will only use the missing values specified in `na_values`.


```{.python}
survey_visited_2 = pd.read_csv(path, keep_default_na = False)
```

::: 


##  Where Can Missing Values Come From?
###  Merged Data

- Let's merge `survey_visited_0` with `survey`.
```{.python}
path = 'https://bcdanl.github.io/data/survey_survey.csv'
survey = pd.read_csv(path)
survey

vs = survey_visited_0.merge(survey, left_on='ident', right_on='taken')
vs
```




##  Where Can Missing Values Come From?
### Reindexing

::: {.panel-tabset}
## (1)
Another way to introduce missing values into our data is to reindex our dataframe. 

  - This is useful when we want to add new indices to your dataframe, but still want to retain its original values. 
  - A common usage is when the index represents some time interval, and we want to add more dates.
  
```{.python}
gapminder = pd.read_csv('https://bcdanl.github.io/data/gapminder.tsv', sep='\t')
life_exp = gapminder.groupby(['year'])['lifeExp'].mean()
```


## (2)
-  We can reindex the dataframe by using the `.reindex()` method.

```{.python}
## subset
y2000 = life_exp[life_exp.index > 2000]

## reindexing
y2000.reindex(range(2000, 2010))
```

::: 








##   Working With Missing Data
### Find and Count Missing Data

::: {.panel-tabset}
## .count()
One way to look at the number of missing values is to `count()` them.

```{.python}
ebola = pd.read_csv('https://bcdanl.github.io/data/country_timeseries.csv')
## count the number of non-missing values
ebola.count()
```

**Q**. Count the number of non-missing values for each variable in `ebola`.



## np.count_nonzero()
If we want to count the total number of missing values in our DataFrame, or count the number of missing values for a particular column, we can use the `np.count_nonzero()` function from numpy in conjunction with the `.isnull()` method.

```{.python}
np.count_nonzero(ebola.isnull())
np.count_nonzero(ebola['Cases_Guinea'].isnull())
```



## .value_counts(dropna=False)

Another way to get missing data counts is to use the `.value_counts()` method, giving a frequency table of values in a Series. 
  - If we use the `dropna = False`, we can also get a missing value count.

```{.python}
cnts = ebola['Cases_Guinea'].value_counts(dropna=False)
cnts
```

- The results are sorted so we can subset the count vector to just look at the missing values.

```{.python}
cnts.loc[pd.isnull(cnts.index)]
```


## .sum()

- In Python, `True` values equate to the integer value 1, and `False` values equate to the integer value 0. 
  - We can use this behavior to get the number of missing values by summing up a boolean vector with the `.sum()` method.

```{.python}
ebola.Cases_Guinea.isnull().sum()
```

::: 





##   Working With Missing Data
###  Clean Missing Data

::: {.panel-tabset}
## Cleaning NaN

There are many different ways we can deal with missing data. 
  1. We can replace the missing value with another value, 
  2. We can fill in the cells with the missing value using existing value, 
  3. We can drop the observations with missing values from our DataFrame.



## .fillna()
- We can use the `.fillna()` method to recode the missing values to another value.

```{.python}
## fill the missing values to 0
ebola0 = ebola.fillna(0)
```



## .fillna(method='ffill')

- We can use built-in methods to fill forward (`method = ffill`).

  -  When we fill data forward, the last known value (from top to bottom) is used for the next missing value.
  

```{.python}
ebola_f = ebola.fillna(method='ffill')
```




## .fillna(method='bfill')

- We can also use built-in methods to fill backward (`method = bfill`).

  -  When we fill data backward, the newest value (from top to bottom) is used to replace the missing data.

```{.python}
ebola_b = ebola.fillna(method='bfill')
```




## .interpolate()
- Interpolation uses existing values to fill in missing values.
  - By default, `.interpolate()` treats the missing values as if they should be equally spaced apart.
```{.python}
ebola_linear = ebola.interpolate()
```

- The `.interpolate()` method  behaves kind of in a forward fill fashion.




## .dropna()

If we want to keep the observations with only non-missing values, we can use `.dropna()`
```{.python}
ebola_dropna = ebola.dropna()
```

We are left with just one row of data!



## Calculation

Suppose we wanted to look at the case counts for multiple regions. 

:::: {.columns}
::: {.column width="50%"}
```{.python}
ebola["Cases_multiple"] = (
  ebola["Cases_Guinea"]
  + ebola["Cases_Liberia"]
  + ebola["Cases_SierraLeone"]
)
```
:::

::: {.column width="50%"}
```{.python}
ebola_subset = ebola.loc[:,
    ["Cases_Guinea", 
     "Cases_Liberia", 
     "Cases_SierraLeone",
     "Cases_multiple"] ]
```
:::
::::




## skipna

`.mean()` and `.sum()` can ignore missing values. 
  - These functions will typically have a `skipna` parameter that will still calculate a value by skipping over the missing values.

```{.python}
ebola.Cases_Guinea.sum(skipna = True) ## default
ebola.Cases_Guinea.sum(skipna = False)
```


::: 






##   Working With Missing Data
###   Pandas Built-In `NA` Missing

Pandas 1.0 introduced a built-in `<NA>` value (`pd.NA`).

```{.python}

economists = pd.DataFrame(
  {
    "Name": ["John Forbes Nash", "William Nordhaus"],
    "Occupation": ["Mathematician", "Climate Economist"],
    "Born": ["1928-06-13", "1941-05-31"],
    "Died": ["2015-05-23", ""],
    "Age": [86, 81]
  }
)

economists.loc[1, "Age"] = pd.NA

```


# `datetime` Data {background-color="#1c4982"}


## Dates and Times
### Python's `datetime` Object

One of the bigger reasons for using Pandas is its ability to work with timeseries data.

- We can use `datetime` to get the current date and time.

```{.python}
from datetime import datetime
now = datetime.now()
```

- We can also create our own `datetime` manually.

```{.python}

t1 = datetime.now()
t2 = datetime(2000,1,1)

diff = t1 - t2
type(diff)
```



## Dates and Times
###  Converting to datetime
::: {.panel-tabset}
## data

-  Let’s load up our Ebola data set and convert the Date column into a proper datetime object.
```{.python}
import pandas as pd
ebola = pd.read_csv('https://bcdanl.github.io/data/country_timeseries.csv')
ebola.info()

```

- The `Date` column is encoded as a generic string `object`.


## `.to_datatime()`
-  We can use `.to_datatime()` to create a new column, `date_dt`, that converts the `Date` column into a `datetime`.

```{.python}
ebola['date_dt'] = pd.to_datetime(ebola['Date'])
```


## format

- The `to_datetime()` method has a parameter called `format` that allows us to manually specify the format of the date.
```{python}

ebola['date_dt'] = pd.to_datetime(ebola['Date'], format='%m /%d/%Y')

ebola['date_my'] = pd.to_datetime(ebola['Date'], format='%m /%Y')
```


## parse_dates
 The `read_csv()` function has several parameters about `datetime`.
  -  We can parse the `Date` column directly by specifying the column we want in the `parse_dates` parameter.
```{.python}
ebola = pd.read_csv('https://bcdanl.github.io/data/country_timeseries.csv', parse_dates=["Date"])
```



::: 



## Dates and Times
### Extracting Date Components


Now that we have a datetime object, we can extract various parts of the date, such as **year**, **month**, or **day**.

Let's consider the example `datetime` object.

```{.python}
d = pd.to_datetime('2021-12-14')
type(d)
d.year
d.month
d.day
d.quarter
```




## Dates and Times
### Extracting Date Components in DataFrame

- We can extract various parts of the `datetime` column in DataFrame by accessing `datetime` methods using the `.dt` accessor.

```{.python}
ebola['date_dt'] = pd.to_datetime(ebola['Date'])

ebola = ebola.assign(
    year = ebola["date_dt"].dt.year,
    month = ebola["date_dt"].dt.month,
    day = ebola["date_dt"].dt.day
)

ebola.info() ## what are the data types of year, month, and day?
```





## Dates and Times
### Date Ranges
::: {.panel-tabset}
## (1)

- In our Ebola data set, we do not have an observation for every day in the date range.
  - This is quite common.

```{.python}
ebola = pd.read_csv(
'https://bcdanl.github.io/data/country_timeseries.csv', parse_dates=["Date"]
)
```

- Here, `2015-01-01` is missing.



## (2)
- It’s common practice to create a date range to `.reindex()` a data set. 
  - We can use the `date_range()`.
  
```{.python}
head_range = pd.date_range(start='2014-12-31', end='2015-01-05')
ebola_5 = ebola.head()
ebola_5.index = ebola_5['Date']
ebola_5 = ebola_5.reindex(head_range)
```





## (3)
  
```{.python}
ebola = pd.read_csv(
  "https://bcdanl.github.io/data/country_timeseries.csv",
  index_col="Date",
  parse_dates=["Date"],
)

new_idx = pd.date_range(ebola.index.min(), ebola.index.max())
new_idx = reversed(new_idx) ## to reverse new_idx
ebola = ebola.reindex(new_idx)

```




::: 


<script>

document.addEventListener('wheel', function(event) {
    if (event.deltaY > 0) {
        Reveal.next(); // Scroll down to go to the next slide
    } else {
        Reveal.prev(); // Scroll up to go to the previous slide
    }
}, false);

window.onload = function() {
    document.querySelectorAll('a').forEach(function(link) {
        link.setAttribute('target', '_blank');
    });
};


document.addEventListener('DOMContentLoaded', function() {
  // Query all anchor tags within code blocks (adjust the selector as needed)
  document.querySelectorAll('pre code a').forEach(function(element) {
    element.addEventListener('click', function(e) {
      e.preventDefault(); // Prevent the default anchor action
      e.stopPropagation(); // Stop the event from bubbling up
    });
  });
});


document.addEventListener('DOMContentLoaded', function() {
    // Target all span elements within code blocks that have IDs starting with 'cb'
    document.querySelectorAll('pre code span[id^="cb"]').forEach(function(element) {
        element.addEventListener('mouseenter', function() {
            // Apply yellow background color to the hovered span element
            this.style.backgroundColor = '#FFFF99';
        });
        element.addEventListener('mouseleave', function() {
            // Revert the background color when the mouse leaves the span element
            this.style.backgroundColor = '';
        });
    });
});
</script>